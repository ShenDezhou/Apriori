-------
SUMMARY
-------
The program is a demonstration of association rule mining using Apriori algorithm.

---------------
BUILD & EXECUTE
---------------
The program has been developed in C.
The code development linux environment running CentOS Linux release 7.2.1511.
gcc version 4.8.5 was used to compile.
To compile the source code, run the make command, which will produce the executable Diggers using the targets mentioned in the makefile.
After compiling the application can be executed by runnning the below, 
$./Diggers

--------------
INPUT & OUTPUT
--------------
Interactive command line inputs are required.
The program takes three inputs,
	File Name -	Name of the file containing the data for mining. 
			The input can also be prefixed by path if the file is in a different location than that of execution.
			The columns are space separated.
			First line should be column header.
	Support rate -	The minimum percentage of occurence of the item set in total population.
			Takes a numeric value of 0.01 to 100.00. If more than 2 decimal places are present then it is rounded.
	Confidence rate-The minimum percentage of occurence of the item A when item B is present(B->A).
			Takes a numeric value of 0.01 to 100.00. If more than 2 decimal places are present then it is rounded.
Output is printed in the screen along with the performance statistics.
The output is also stored in a file name Rules.

Sample:
Enter the input file name:data1
NOTE:
        *Inputs are in percentage*
        *Accepts numeric values ranging 0.01 to 100.00*

Enter the support rate:20
Enter the confidence rate:20

-----------
PERFORMANCE
-----------
The execution time for the application is measured accross three different tasks loading input, rule mining and output extraction.
Given below is the statistics for the 3 sample inputs with support rate=20% & confidence rate=20%.

Time provided below is in milli seconds.
	|Rules	|Loading	|Generation	|Extraction
-----------------------------------------------------------
Data1	|076	|00.515		|01.461		|06.978
Data2	|148	|02.050		|03.887		|15.502
Data3	|444	|01.706		|13.623		|29.619

The statistics shows that execution time is fairly faster with a highest of 13 milli second.
Considerable time has been consumed in extraction, this can be reduced further by not printing in the screen and developing ways to bulk write in file.

-----------
ASSUMPTIONS
-----------
Field should not have space in between.
Input file should not have empty columns.
Items or values should be unique to a feild i.e. two columns should not contain same value.
Support rate and confidence rate are always represented in percentage taking value greater than 0 till 100.
Support rate and confidence rate values can take upto two decimal places and anything more is rounded off.

--------------
DATA STRUCTURE
--------------
Tree style data structure is used to represent the data.
The tree does not have root, instead has multiple individual items in root level.
Each level k indicating k-item itemset, starting from root level indicating 1-item itemset.
Each node in the level  k contains the k frequent items and their combined support rate.

The same tree structure is recursed at each node to store the rules generated by the items.
Each recursed tree(rule tree) has levels and nodes separately.
Level k in rule tree contains the rules formed with k-items in the right component of the rule.
Nodes in level k represent specific rule and contain items in the right component along with confidence percentage.
Right side is chosen for data structure since it can be used in apriori and pruning parameters at lower level i.e. if AB->C is not good then A->BC & B->AC is also not good.
The items of left side component can be got from the difference between the parent items and the right component.

The recursive use of data structure helps developing a single Apriori and pruning module to use both in support rate and confidance rate validation.
Though different piece of code is used in this application, it can be seen that both follow a same patern only with little difference. Further analysis can result in perfecting this.

---------------
MODULES & TASKS
---------------
The code contain the below files,
	diggers.h - Structure, Global variable and Function declaration.
	diggers.c - main() program.
	load.c - Reads data from input and forms the items.
	item_gen.c - Item set generation and populate the data structure.
	item_prune.c - Called during item set generation to perform the Apriori and support rate validation.
	rule_gen.c - Generates the rules for the item sets and populates the data structure.
	rule_prune.c - Called during rule generation to perform the Apriori and confidence rate validation.
	extract.c - Reads the generated rules from the data structure and outputs to the screen & file.

Given below the flow of control between modules,

digger:main()
  |
  |
LOAD-->load()			#file name input
  |      |
  |	 |
  |    load_headers()		#read first line from file. gathers info such as number of columns and column names.
  |      |
  |	 |
  |    load_records()		#read all records. gather info such as number records, unique items and record info.
  |				#assign numeric index for each item.
  |
  |
ITEM_GEN-->lvl_1_gen()		#generate level 1, idividual frequent items. contains inline frequent item check
  |		|
  |		|
  |	   lvl_n_gen()-->apriori_prune()	#generate items using cross over on n-1 itemset. calls apriori function.
  |						#apriori function validates against n-1 to check all subsets are present.
  |						#also support rate is validated.
  |
  |
RULE_GEN-->lvl_1_rule()-->find_sup()		#for all items, generate all rules with 1 item on right ride.
  |		|				#call find support rate for left item. Search in the items gen structure.
  |		|				#divide parent sup.rate by left sup.rate to get conf.rate & validate.
  |		|
  |		|
  |	   lvl_n_rule()-->apriori_prune_rule()-->find_sup()	#generate rules with n items on right side using,
  |								#	cross over of n-11 item right side rules.
  |								#apprior validation to check subsets in n-1 right side.
  |								#conf.rate validation same as previous step.
  |
  |	
EXTRACT-->extract()-->print_rule()		#output header. loops through each itemset->item->rule_level->rule
						#print_rule forms the left component of the rule and prints the rule.
